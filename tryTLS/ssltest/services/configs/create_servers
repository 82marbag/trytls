#!/bin/bash

service=$1
port=$2
first_port=$port
hostname=$3
current_hostname=$hostname
protocol=$4
filepath=$5

FIS=$IFS
IFS=$' & '


#inst = instruction, value = value
while read -r inst value; do
	if [ "$value" ]; then
		case $inst in 
			"value")
				if [[ "$value" == "inc" ]]; then
					temp=`cat tmp/value`
					(( temp++ )) 
					echo $temp > tmp/value || exit 1
				else
					echo $value > tmp/value
				fi
				;;
			"server")
				#set server value and create folders
				server=$value
				
				mkdir -p $service/server/$server/ssl
				;;
			"msg")
				#set message ($service/server/$server/index.html)
				msg=$value
				;;
			"set_crt")
				#set cert (name)
				crt=$value
				echo "testing_ " $service/$current_hostname/server/$crt/ssl
				if [[ "$protocol" == "https" ]]; then
					mkdir -p $service/server/$crt/ssl
				elif [[ "$protocol" == "ftps" ]]; then
					mkdir -p $service/$current_hostname/server/$crt/ssl
				fi
				;;
			"create_crt")
				#create signing request
				if [ "$value" ]; then		#voidaan asettaa crt samalla kun se tehdään
					if [[ "$value" == "hostname" ]]; then
						crt=$current_hostname
					else
						crt=$value
					fi
				fi

				if [[ "$protocol" == "https" ]]; then				#if not created
					mkdir -p $service/server/$crt/ssl
				elif [[ "$protocol" == "ftps" ]]; then
					mkdir -p $service/$current_hostname/server/$crt/ssl
				fi
			
				#create extensions file (could be done with .cnf as well), this can be moved to it's own ext) if seen better
				echo "subjectAltName = DNS:*.$san, DNS:$san" > tmp/server.ext
				#IdenTrust
				openssl req -new -key tmp/server.key -out tmp/server.csr -subj "/C=FI/ST=Oulu/L=Oulu/O=ouspg/OU=ouspg/CN=$cn"
				#create certificate
				openssl x509 -req -days $days -in tmp/server.csr -signkey tmp/server.key -out tmp/certs/trytls_$crt.crt -extfile tmp/server.ext
				chmod 755 tmp/certs/trytls_$crt.crt
				
				;;
			"ssl_protocols")
				#set $proto
				proto=$value
				;;
			"ssl_ciphers")
				#set $ciph
				ciph=$value
				;;
			"days")
				#set days, if days = 0, use firstday, lastday
				days=$value
				;;
			"set_current_hostname_cat") 
				if [[ "$value" == "hostname" ]]; then
					value=$hostname
				fi
				current_hostname="$value`cat tmp/value`"	#e.g: 222.222.222. + 2				
				;;
			"set_current_hostname")
				if [[ "$value" == "hostname" ]]; then
					current_hostname=$hostname
				else
					current_hostname=$value
				fi				
				;;
			"host")
				#set common name
				if [[ "$value" == "hostname" ]]; then
					san=$current_hostname
					cn=$current_hostname	
				else
					san=$value
					cn=$value
				fi
				;;
			"san")
				if [[ "$value" == "hostname" ]]; then
					san=$current_hostname
				else
					san=$value
				fi
				;;
			"cn")
				if [[ "$value" == "hostname" ]]; then
					cn=$current_hostname
				else
					cn=$value
				fi
				;;	
			"push")

				if [[ "$value" && "$value" != "no_change" ]]; then		#voidaan asettaa crt samalla kun se tehdään
					if [[ "$value" == "hostname" ]]; then
						crt=$current_hostname
					else
						crt=$value
					fi
				fi

				{ echo -e "server: $service/$server\n\tport: $port using $crt.crt" ;
				  echo -e "\tprotocols: $proto ciphers: $ciph" ; } | tee -a tmp/server_info
				
				echo $msg > $service/server/$server/index.html

				echo "$port & $msg & trytls_$crt.crt & $current_hostname" >> tmp/messages

				if [[ "$protocol" == "https" ]]; then

					#cp CERT AND KEY

					cp tmp/certs/trytls_$crt.crt $service/server/$crt/ssl/server.crt
					cp tmp/server.key $service/server/$server/ssl/server.key

					#DOCKERFILE

					{ echo "" ; echo "# $server "; } >> $service/Dockerfile || exit 1 

					{ echo "ADD server/$server/index.html /usr/share/nginx/server/$server/html/index.html"; \
					echo "ADD server/$crt/ssl/server.crt /etc/nginx/server/$crt/ssl/server.crt"; } \
					>> $service/Dockerfile || exit 1
				
					#DEFAULT CONF

					{ echo "" ; echo "# $server " ; \
					echo 'server {' ; \
					echo "	listen $port;" ; \

					echo '	ssl on; ' ; \
					echo "	ssl_certificate server/$crt/ssl/server.crt; " ; \
					echo '	ssl_certificate_key server/server.key;' ;\

					echo '	location /server/ { ' ;\
					echo '	  deny all; ' ;\
					echo '	  return 403; ' ;\
					echo '	} ' ;\

					echo "	root /usr/share/nginx/server/$server/html/;" ;\
					echo '	index index.html;' ;\

					echo "	ssl_protocols       $proto" ;\
					echo "	ssl_ciphers         $ciph" ;\

					echo '	server_name trytls;' ;\

					echo '	location / {' ;\
					echo '		try_files $uri $uri/ /index.html;' ;\
					echo '	}' ;\
					echo '}' ; } >> $service/default.conf || exit 3
				elif [[ "$protocol" == "ftps" ]]; then

					#initial testing, most likely some bugs, etc..

					#cp CERT AND KEY

					cp tmp/certs/trytls_$crt.crt $service/$current_hostname/server/$crt/ssl/server.crt
					mkdir -p $service/server/$server/$current_hostname/server
					cp tmp/server.key $service/$current_hostname/server/server.key					

					#Dockerfile

					#mkdir $service/$current_hostname

					{ echo "FROM debian:jessie" ; \

					echo "RUN apt-get update "'\' ; \
					echo "	&& apt-get install -y --no-install-recommends vsftpd db5.3-util "'\' ; \
					echo "	&& apt-get clean "'\' ; \
					echo "	&& rm -rf /var/lib/apt/lists/*" ; \

					echo "RUN mkdir -p /var/run/vsftpd/empty" ; \
					echo "RUN touch /var/run/vsftpd/empty/empty" ; \

					echo "ADD default.conf /etc/vsftpd.conf" ; \
					echo "ADD server/$crt/ssl/server.crt /etc/vsftpd/server/server.crt"
					echo "ADD server/server.key /etc/vsftpd/server/server.key" ; \

					echo "RUN adduser user" ; \
					echo "RUN echo 'user:passwd' | chpasswd" ; \

					echo "EXPOSE 990" ; \
					echo "EXPOSE 21" ; \

					echo "CMD  vsftpd;" ; } > $service/$current_hostname/Dockerfile

					#default.conf (vsftpd, debian)" ; } > 

					ciphers=${ciph: : -1}

					{ echo "listen=NO" ; \

					echo "listen_ipv6=YES" ; \

					echo "anonymous_enable=NO" ; \

					echo "local_enable=YES" ; \
					#write_enable=YES"

					#let's get ciphers, and used ssl protocols:

					#local_umask=022	uncomment and test
					echo "dirmessage_enable=YES" ; \
					echo "use_localtime=YES" ; \

					echo "xferlog_enable=YES" ; \
					echo "connect_from_port_20=YES" ; \
					
					echo "pam_service_name=ftp" ; \
					
					echo "secure_chroot_dir=/var/run/vsftpd/empty" ; \
					echo "pam_service_name=vsftpd" ; \


					echo "rsa_cert_file=/etc/vsftpd/server/server.crt" ; \
					echo "rsa_private_key_file=/etc/vsftpd/server/server.key" ; \

					echo "ssl_enable=YES" ; \
					echo "allow_anon_ssl=NO" ; \
					echo "force_local_data_ssl=YES" ; \
					echo "force_local_logins_ssl=YES" ; \

					echo "ssl_tlsv1=YES" ; \
					echo "ssl_sslv2=NO" ; \
					echo "ssl_sslv3=NO" ; \

					echo "require_ssl_reuse=NO" ; \
					echo "ssl_ciphers=$ciphers" ; } > $service/$current_hostname/default.conf

					#docker-compose	(add needed lines (network, build, etc..))

					{ echo " $service$server:" ; \
					echo "  build: $service/$current_hostname" ; \
					echo "  container_name: $service$server" ; \
					echo "  networks:" ; \
					echo "    trytls_net:" ; \
					echo "      ipv4_address: $current_hostname" ; } >> docker-compose.yml || exit 2


				fi
				#inc port number by one

				(( port++ ))


				;;
		esac
	fi
done <"$filepath"

IFS=$FIS

#update docker-compose

if [[ $protocol == "https" && $service != "initialize" ]]; then

	(( last_port = port - 1 ))

	{ echo " $service:" ;\
	  echo "  build: $service" ;\
	  echo "  container_name: $service"  ;\
	  echo '  ports:' ;\
	  echo '  - "'"$first_port-$last_port:$first_port-$last_port"'"' ; }\
		>> docker-compose.yml || exit 4

	#copy private key, server.key server/. directoryyn

	cp tmp/server.key $service/server/server.key

fi

#save current port (== next server's port)

echo $port > tmp/port


#TODO: more clear + maybe something more(i.e. localhost, etc..)

